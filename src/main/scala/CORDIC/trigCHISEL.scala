package CORDIC

import chisel3._
import chisel3.util._

object CordicSimplifiedConstants {
  val CORDIC_K_DBL: Double = 0.6072529350088813 // Gain of CORDIC rotation/vectoring

  /* Converts a Double to a BigInt representing a fixed-point number */
  def doubleToFixed(x: Double, fractionalBits: Int, width: Int): BigInt = {
    val scaled = BigDecimal(x) * BigDecimal(BigInt(1) << fractionalBits)
    val rounded = scaled.setScale(0, BigDecimal.RoundingMode.HALF_UP).toBigInt
    val maxVal = (BigInt(1) << (width - 1)) - 1
    val minVal = -(BigInt(1) << (width - 1))
    rounded.max(minVal).min(maxVal)
  }

  def getAtanLUT(fractionalBits: Int, width: Int, numEntries: Int): Seq[SInt] = {
    (0 until numEntries).map { i =>
      val angle_rad = math.atan(math.pow(2.0, -i))
      doubleToFixed(angle_rad, fractionalBits, width).S(width.W)
    }
  }
}

class CordicSimplified(val width: Int, val cycleCount: Int, val integerBits: Int = 3) extends Module {
  // Parameter Validations
  require(width > 0, "Width must be positive")
  require(cycleCount > 0, "Cycle count must be positive")
  require(integerBits >= 1, "Integer bits must be at least 1 (for sign or small numbers)") // Allowing for values like 0.x or 1.x
  val fractionalBits: Int = width - 1 - integerBits // 1 bit for sign
  require(fractionalBits > 0, s"Fractional bits must be positive. Check width ($width) vs integerBits ($integerBits). FractionalBits = $fractionalBits")

  val io = IO(new Bundle {
    // Control
    val start = Input(Bool())
    val doArctan = Input(Bool()) // true for ArcTan (vectoring), false for Sin/Cos (rotation)

    // Data Inputs
    val targetTheta = Input(SInt(width.W)) 
    val inputX = Input(SInt(width.W))      
    val inputY = Input(SInt(width.W))      

    // Data Outputs
    val done = Output(Bool())
    val cosOut = Output(SInt(width.W))   
    val sinOut = Output(SInt(width.W))    
    val arctanOut = Output(SInt(width.W)) 
  })

  // --- Fixed-point constants for CORDIC calculations ---
  val K_fixed = CordicSimplifiedConstants.doubleToFixed(CordicSimplifiedConstants.CORDIC_K_DBL, fractionalBits, width).S(width.W)

  val X_INIT_SINCOS_fixed = CordicSimplifiedConstants.doubleToFixed(1.0 , fractionalBits, width).S(width.W)
  val Y_INIT_SINCOS_fixed = 0.S(width.W)

  // Arctan lookup table (ROM). Contents generated by getAtanLUT.
  val atanLUT = VecInit(CordicSimplifiedConstants.getAtanLUT(fractionalBits, width, cycleCount))

  // --- State Machine Definition ---
  object s extends ChiselEnum {
    val idle, busy, done = Value
  }
  val state = RegInit(s.idle)

  // --- Registers for CORDIC iterative values ---
  val x_reg = Reg(SInt(width.W))
  val y_reg = Reg(SInt(width.W))
  val z_reg = Reg(SInt(width.W)) 
  // iter_count goes from 0 to cycleCount-1 for iterations, then to cycleCount to signal completion
  val iter_count = Reg(UInt(log2Ceil(cycleCount + 1).W))
  val opIsArctan = Reg(Bool()) // Store operation mode during processing

  // --- Default output values ---
  io.done := false.B
  io.cosOut := 0.S    
  io.sinOut := 0.S
  io.arctanOut := 0.S

  // --- State Machine Logic ---
  switch(state) {
    is(s.idle) {
                //printf("State: Idle\n")
      when(io.start) {

        opIsArctan := io.doArctan
        
        when(io.doArctan) { // ArcTan (Vectoring mode)

          x_reg := io.inputX
          y_reg := io.inputY
          z_reg := 0.S(width.W) 
        }.otherwise { // Sin/Cos (Rotation mode)

          x_reg := X_INIT_SINCOS_fixed // Start with vector (1,0) effectively
          y_reg := Y_INIT_SINCOS_fixed
          z_reg := io.targetTheta     
        }
        iter_count := 0.U
        state := s.busy
      }
    }

    is(s.busy) {
      // Perform iterations as long as iter_count < cycleCount
      when(iter_count < cycleCount.U) {
                            //printf(p"$iter_count")
        val current_i = iter_count // Current iteration index, used for shifts and LUT access

        val y_shifted = y_reg >> current_i
        val x_shifted = x_reg >> current_i
        
        val delta_theta = atanLUT(current_i)
        val direction = Wire(SInt(2.W))      // Direction of rotation/vectoring (+1 or -1)

        when(opIsArctan) { // Vectoring mode (calculating ArcTan)

          val d_vec = Mux(y_reg >= 0.S, 1.S, -1.S)
          direction := d_vec // Assign to the common 'direction' wire

          x_reg := x_reg + (direction * y_shifted) 
          y_reg := y_reg - (direction * x_shifted) 
          z_reg := z_reg + (direction * delta_theta) 

        }.otherwise { // Rotation mode (calculating Sin/Cos)
          val d_rot = Mux(z_reg >= 0.S, 1.S, -1.S)
          direction := d_rot // Assign to the common 'direction' wire
          
          x_reg := x_reg - (direction * y_shifted) // x_new = x_old - d*y_shifted
          y_reg := y_reg + (direction * x_shifted) // y_new = y_old + d*x_shifted
          z_reg := z_reg - (direction * delta_theta) // z_new = z_old - d*angle
        }
        iter_count := iter_count + 1.U
      }.otherwise { 
        state := s.done
      }
    }

    is(s.done) {
                //printf("State: Done\n")
                //printf(p"Final results: cosOut = ${io.cosOut}, sinOut = ${io.sinOut}, arctanOut = ${io.arctanOut}\n")

      io.done := true.B

      when(opIsArctan) {
        io.cosOut    := 0.S 
        io.sinOut    := 0.S 
        io.arctanOut := z_reg // This is the accumulated angle
      }.otherwise { // Sin/Cos mode

        val cos_uncorrected = x_reg
        val sin_uncorrected = y_reg

        val cos_full_prod = cos_uncorrected.asSInt * K_fixed.asSInt
        val sin_full_prod = sin_uncorrected.asSInt * K_fixed.asSInt
        
        io.cosOut := (cos_full_prod >> fractionalBits.U).asSInt
        io.sinOut := (sin_full_prod >> fractionalBits.U).asSInt
        io.arctanOut := z_reg
      }
      // After outputting for one cycle, return to Idle.
      state := s.idle
    }
  }
}

