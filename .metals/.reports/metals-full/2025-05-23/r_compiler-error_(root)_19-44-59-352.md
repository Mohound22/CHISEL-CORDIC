error id: 265D00885E2F825AEC27CC86E86A935A
file://<WORKSPACE>/src/main/scala/CORDIC/trigCHISEL.scala
### scala.ScalaReflectionException: value sinOut is not a method

occurred in the presentation compiler.



action parameters:
uri: file://<WORKSPACE>/src/main/scala/CORDIC/trigCHISEL.scala
text:
```scala
package CORDIC

import chisel3._
import chisel3.util._

object CordicSimplifiedConstants {
  val CORDIC_K_DBL: Double = 0.6072529350088813 // Gain of CORDIC rotation/vectoring

  /* Converts a Double to a BigInt representing a fixed-point number */
  def doubleToFixed(x: Double, fractionalBits: Int, width: Int): BigInt = {
    val scaled = BigDecimal(x) * BigDecimal(BigInt(1) << fractionalBits)
    val rounded = scaled.setScale(0, BigDecimal.RoundingMode.HALF_UP).toBigInt
    val maxVal = (BigInt(1) << (width - 1)) - 1
    val minVal = -(BigInt(1) << (width - 1))
    rounded.max(minVal).min(maxVal)
  }

  def getAtanLUT(fractionalBits: Int, width: Int, numEntries: Int): Seq[SInt] = {
    (0 until numEntries).map { i =>
      val angle_rad = math.atan(math.pow(2.0, -i))
      doubleToFixed(angle_rad, fractionalBits, width).S(width.W)
    }
  }
}

class CordicSimplified(val width: Int, val cycleCount: Int, val integerBits: Int = 3) extends Module {
  // Parameter Validations
  require(width > 0, "Width must be positive")
  require(cycleCount > 0, "Cycle count must be positive")
  require(integerBits >= 1, "Integer bits must be at least 1 (for sign or small numbers)") // Allowing for values like 0.x or 1.x
  val fractionalBits: Int = width - 1 - integerBits // 1 bit for sign
  require(fractionalBits > 0, s"Fractional bits must be positive. Check width ($width) vs integerBits ($integerBits). FractionalBits = $fractionalBits")

  val io = IO(new Bundle {
    // Control
    val start = Input(Bool())
    val doArctan = Input(Bool()) // true for ArcTan (vectoring), false for Sin/Cos (rotation)

    // Data Inputs
    val targetTheta = Input(SInt(width.W)) // For Sin/Cos mode: target angle in radians (fixed-point)
    val inputX = Input(SInt(width.W))      // For ArcTan mode: X coordinate (fixed-point)
    val inputY = Input(SInt(width.W))      // For ArcTan mode: Y coordinate (fixed-point)

    // Data Outputs
    val done = Output(Bool())
    val cosOut = Output(SInt(width.W))    // Result for Sin/Cos (X' * K or just X'), or 0 for Arctan
    val sinOut = Output(SInt(width.W))    /
    val arctanOut = Output(SInt(width.W)) // Result for ArcTan (accumulated angle Z'), or residual angle for Sin/Cos
  })

  // --- Fixed-point constants for CORDIC calculations ---
  val K_fixed = CordicSimplifiedConstants.doubleToFixed(CordicSimplifiedConstants.CORDIC_K_DBL, fractionalBits, width).S(width.W)
  // Initial X for Sin/Cos mode is 1.0 (scaled).
  // The Scala model applied K later. If pre-scaling by 1/K, this would be CordicSimplifiedConstants.doubleToFixed(1.0 / CordicSimplifiedConstants.CORDIC_K_DBL,...)
  val X_INIT_SINCOS_fixed = CordicSimplifiedConstants.doubleToFixed(1.0 , fractionalBits, width).S(width.W)
  val Y_INIT_SINCOS_fixed = 0.S(width.W)

  // Arctan lookup table (ROM). Contents generated by getAtanLUT.
  val atanLUT = VecInit(CordicSimplifiedConstants.getAtanLUT(fractionalBits, width, cycleCount))

  // --- State Machine Definition ---
  object s extends ChiselEnum {
    val idle, busy, done = Value
  }
  val state = RegInit(s.idle)

  // --- Registers for CORDIC iterative values ---
  val x_reg = Reg(SInt(width.W))
  val y_reg = Reg(SInt(width.W))
  val z_reg = Reg(SInt(width.W)) // Holds angle for rotation mode, accumulates angle for vectoring
  // iter_count goes from 0 to cycleCount-1 for iterations, then to cycleCount to signal completion
  val iter_count = Reg(UInt(log2Ceil(cycleCount + 1).W))
  val opIsArctan = Reg(Bool()) // Store operation mode during processing

  // --- Default output values ---
  io.done := false.B
  io.cosOut := 0.S       // Default to 0 or hold previous value. Defaulting to 0.
  io.sinOut := 0.S
  io.arctanOut := 0.S

  // --- State Machine Logic ---
  switch(state) {
    is(s.idle) {
                //printf("State: Idle\n")
      when(io.start) {

        opIsArctan := io.doArctan
        
        when(io.doArctan) { // ArcTan (Vectoring mode)
          // Scala model: assert(inputX >= 0). Assuming valid inputs.
          x_reg := io.inputX
          y_reg := io.inputY
          z_reg := 0.S(width.W) // Accumulator for angle
        }.otherwise { // Sin/Cos (Rotation mode)
          // Scala model: assert range for targetTheta. Assuming valid inputs.
          x_reg := X_INIT_SINCOS_fixed // Start with vector (1,0) effectively
          y_reg := Y_INIT_SINCOS_fixed
          z_reg := io.targetTheta      // Angle to reduce to zero
        }
        iter_count := 0.U
        state := s.busy
      }
    }

    is(s.busy) {
      // Perform iterations as long as iter_count < cycleCount
      when(iter_count < cycleCount.U) {
                            //printf(p"$iter_count")
        val current_i = iter_count // Current iteration index, used for shifts and LUT access

        val y_shifted = y_reg >> current_i
        val x_shifted = x_reg >> current_i
        
        val delta_theta = atanLUT(current_i)
        val direction = Wire(SInt(2.W))      // Direction of rotation/vectoring (+1 or -1)

        when(opIsArctan) { // Vectoring mode (calculating ArcTan)
          // Determine direction for vectoring mode
          // Scala: if (yPrime < 0) direction = 1 else direction = -1
          // To make y_reg approach 0:
          // If y_reg > 0, rotate negatively (standard CORDIC d_i = +1)
          // If y_reg < 0, rotate positively (standard CORDIC d_i = -1)
          val d_vec = Mux(y_reg >= 0.S, 1.S, -1.S)
          direction := d_vec // Assign to the common 'direction' wire

          x_reg := x_reg + (direction * y_shifted) // x_new = x_old + d*y_shifted
          y_reg := y_reg - (direction * x_shifted) // y_new = y_old - d*x_shifted
          z_reg := z_reg + (direction * delta_theta) // z_new = z_old + d*angle

        }.otherwise { // Rotation mode (calculating Sin/Cos)
          // Determine direction for rotation mode
          // Standard CORDIC: d_i = sign(z_i). If z_i > 0, d_i = +1 (rotate negative).
          val d_rot = Mux(z_reg >= 0.S, 1.S, -1.S)
          direction := d_rot // Assign to the common 'direction' wire
          
          x_reg := x_reg - (direction * y_shifted) // x_new = x_old - d*y_shifted
          y_reg := y_reg + (direction * x_shifted) // y_new = y_old + d*x_shifted
          z_reg := z_reg - (direction * delta_theta) // z_new = z_old - d*angle
        }
        iter_count := iter_count + 1.U
      }.otherwise { // All iterations (0 to cycleCount-1) are complete
        state := s.done
      }
    }

    is(s.done) {
                //printf("State: Done\n")
                //printf(p"Final results: cosOut = ${io.cosOut}, sinOut = ${io.sinOut}, arctanOut = ${io.arctanOut}\n")

      io.done := true.B
      // Values in x_reg, y_reg, z_reg are the final results from iterations.
      when(opIsArctan) {
        // Scala model returned (0.0, 0.0, totalTheta)
        io.cosOut    := 0.S // x_reg would be gain-scaled magnitude if needed
        io.sinOut    := 0.S // y_reg should be close to 0 if needed
        io.arctanOut := z_reg // This is the accumulated angle
      }.otherwise { // Sin/Cos mode
        // x_reg is cos(theta_initial) * Product(cos(atan(2^-i))) = cos(theta_initial) / K_cordic
        // y_reg is sin(theta_initial) * Product(cos(atan(2^-i))) = sin(theta_initial) / K_cordic
        // Need to apply gain correction K_cordic.
        val cos_uncorrected = x_reg
        val sin_uncorrected = y_reg

        // Fixed point multiplication: (A * B) requires a right shift by fractionalBits
        // to realign the decimal point. The intermediate product can be up to 2*width bits.
        val cos_full_prod = cos_uncorrected.asSInt * K_fixed.asSInt
        val sin_full_prod = sin_uncorrected.asSInt * K_fixed.asSInt
        
        // Shift right to restore fractional point and truncate to original width.
        io.cosOut := (cos_full_prod >> fractionalBits.U).asSInt
        io.sinOut := (sin_full_prod >> fractionalBits.U).asSInt
        io.arctanOut := z_reg // This is the residual angle, should be close to zero
      }
      // After outputting for one cycle, return to Idle.
      // If io.start is held high, it might immediately start a new calculation.
      state := s.idle
    }
  }
}


```


presentation compiler configuration:
Scala version: 2.13.14
Classpath:
<WORKSPACE>/.bloop/root/bloop-bsp-clients-classes/classes-Metals-ibh9fzEySUyqPNQLUJdd3A== [exists ], <HOME>/.cache/bloop/semanticdb/com.sourcegraph.semanticdb-javac.0.10.4/semanticdb-javac-0.10.4.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.14/scala-library-2.13.14.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/edu/berkeley/cs/chisel3_2.13/3.6.1/chisel3_2.13-3.6.1.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.14/scala-reflect-2.13.14.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/edu/berkeley/cs/firrtl_2.13/1.6.0/firrtl_2.13-1.6.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/upickle_2.13/2.0.0/upickle_2.13-2.0.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/os-lib_2.13/0.8.1/os-lib_2.13-0.8.1.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/antlr/antlr4-runtime/4.9.3/antlr4-runtime-4.9.3.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/protobuf/protobuf-java/3.18.3/protobuf-java-3.18.3.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/scopt/scopt_2.13/3.7.1/scopt_2.13-3.7.1.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/net/jcazevedo/moultingyaml_2.13/0.4.2/moultingyaml_2.13-0.4.2.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-native_2.13/4.0.6/json4s-native_2.13-4.0.6.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-text/1.10.0/commons-text-1.10.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/io/github/alexarchambault/data-class_2.13/0.2.5/data-class_2.13-0.2.5.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parallel-collections_2.13/1.0.4/scala-parallel-collections_2.13-1.0.4.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/ujson_2.13/2.0.0/ujson_2.13-2.0.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/upack_2.13/2.0.0/upack_2.13-2.0.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/upickle-implicits_2.13/2.0.0/upickle-implicits_2.13-2.0.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/geny_2.13/0.7.1/geny_2.13-0.7.1.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/nscala-time/nscala-time_2.13/2.22.0/nscala-time_2.13-2.22.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/yaml/snakeyaml/1.26/snakeyaml-1.26.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-core_2.13/4.0.6/json4s-core_2.13-4.0.6.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-native-core_2.13/4.0.6/json4s-native-core_2.13-4.0.6.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.12.0/commons-lang3-3.12.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/upickle-core_2.13/2.0.0/upickle-core_2.13-2.0.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/joda-time/joda-time/2.10.1/joda-time-2.10.1.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/joda/joda-convert/2.2.0/joda-convert-2.2.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-ast_2.13/4.0.6/json4s-ast_2.13-4.0.6.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-scalap_2.13/4.0.6/json4s-scalap_2.13-4.0.6.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/thoughtworks/paranamer/paranamer/2.8/paranamer-2.8.jar [exists ]
Options:
-language:reflectiveCalls -deprecation -feature -Xcheckinit -Yrangepos -Xplugin-require:semanticdb




#### Error stacktrace:

```
scala.reflect.api.Symbols$SymbolApi.asMethod(Symbols.scala:240)
	scala.reflect.api.Symbols$SymbolApi.asMethod$(Symbols.scala:234)
	scala.reflect.internal.Symbols$SymbolContextApiImpl.asMethod(Symbols.scala:99)
	scala.tools.nsc.typechecker.ContextErrors$TyperContextErrors$TyperErrorGen$.MissingArgsForMethodTpeError(ContextErrors.scala:810)
	scala.tools.nsc.typechecker.Typers$Typer.adaptMethodTypeToExpr$1(Typers.scala:999)
	scala.tools.nsc.typechecker.Typers$Typer.adapt(Typers.scala:1353)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6276)
	scala.tools.nsc.typechecker.Typers$Typer.typedDefDef(Typers.scala:6525)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:6167)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6261)
	scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:6339)
	scala.tools.nsc.typechecker.Typers$Typer.$anonfun$typedStats$4(Typers.scala:3488)
	scala.tools.nsc.typechecker.Typers$Typer.$anonfun$typedStats$4$adapted(Typers.scala:3483)
	scala.reflect.internal.Scopes$Scope.foreach(Scopes.scala:455)
	scala.tools.nsc.typechecker.Typers$Typer.addSynthetics$1(Typers.scala:3483)
	scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:3551)
	scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:2144)
	scala.tools.nsc.typechecker.Typers$Typer.typedClassDef(Typers.scala:1982)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:6168)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6261)
	scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:6339)
	scala.tools.nsc.typechecker.Typers$Typer.$anonfun$typedStats$9(Typers.scala:3539)
	scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:3539)
	scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2656)
	scala.tools.nsc.typechecker.Typers$Typer.typedOutsidePatternMode$1(Typers.scala:6179)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:6215)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6261)
	scala.tools.nsc.typechecker.Typers$Typer.typedArg(Typers.scala:3557)
	scala.tools.nsc.typechecker.Typers$Typer.handlePolymorphicCall$1(Typers.scala:3961)
	scala.tools.nsc.typechecker.Typers$Typer.doTypedApply(Typers.scala:3980)
	scala.tools.nsc.typechecker.Typers$Typer.normalTypedApply$1(Typers.scala:5256)
	scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:5267)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:6205)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6261)
	scala.tools.nsc.typechecker.Typers$Typer.computeType(Typers.scala:6350)
	scala.tools.nsc.typechecker.Namers$Namer.assignTypeToTree(Namers.scala:1105)
	scala.tools.nsc.typechecker.Namers$Namer.inferredValTpt$1(Namers.scala:1752)
	scala.tools.nsc.typechecker.Namers$Namer.valDefSig(Namers.scala:1765)
	scala.tools.nsc.typechecker.Namers$Namer.memberSig(Namers.scala:1953)
	scala.tools.nsc.typechecker.Namers$Namer.typeSig(Namers.scala:1903)
	scala.tools.nsc.typechecker.Namers$Namer$ValTypeCompleter.completeImpl(Namers.scala:918)
	scala.tools.nsc.typechecker.Namers$LockingTypeCompleter.complete(Namers.scala:2100)
	scala.tools.nsc.typechecker.Namers$LockingTypeCompleter.complete$(Namers.scala:2098)
	scala.tools.nsc.typechecker.Namers$TypeCompleterBase.complete(Namers.scala:2093)
	scala.reflect.internal.Symbols$Symbol.completeInfo(Symbols.scala:1566)
	scala.reflect.internal.Symbols$Symbol.info(Symbols.scala:1538)
	scala.reflect.internal.Symbols$Symbol.initialize(Symbols.scala:1733)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5835)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6261)
	scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:6339)
	scala.tools.nsc.typechecker.Typers$Typer.$anonfun$typedStats$9(Typers.scala:3539)
	scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:3539)
	scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:2144)
	scala.tools.nsc.typechecker.Typers$Typer.typedClassDef(Typers.scala:1982)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:6168)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6261)
	scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:6339)
	scala.tools.nsc.typechecker.Typers$Typer.$anonfun$typedStats$9(Typers.scala:3539)
	scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:3539)
	scala.tools.nsc.typechecker.Typers$Typer.typedPackageDef$1(Typers.scala:5844)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:6171)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6261)
	scala.tools.nsc.typechecker.Analyzer$typerFactory$TyperPhase.apply(Analyzer.scala:125)
	scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:481)
	scala.tools.nsc.interactive.Global$TyperRun.applyPhase(Global.scala:1369)
	scala.tools.nsc.interactive.Global$TyperRun.typeCheck(Global.scala:1362)
	scala.tools.nsc.interactive.Global.typeCheck(Global.scala:680)
	scala.meta.internal.pc.WithCompilationUnit.<init>(WithCompilationUnit.scala:22)
	scala.meta.internal.pc.SimpleCollector.<init>(PcCollector.scala:348)
	scala.meta.internal.pc.PcSemanticTokensProvider$Collector$.<init>(PcSemanticTokensProvider.scala:19)
	scala.meta.internal.pc.PcSemanticTokensProvider.Collector$lzycompute$1(PcSemanticTokensProvider.scala:19)
	scala.meta.internal.pc.PcSemanticTokensProvider.Collector(PcSemanticTokensProvider.scala:19)
	scala.meta.internal.pc.PcSemanticTokensProvider.provide(PcSemanticTokensProvider.scala:73)
	scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$semanticTokens$1(ScalaPresentationCompiler.scala:196)
```
#### Short summary: 

scala.ScalaReflectionException: value sinOut is not a method