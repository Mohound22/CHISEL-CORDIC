error id: file://<WORKSPACE>/src/main/scala/CORDIC/CHISELtrig.scala:chisel3/package.fromIntToWidth#W().
file://<WORKSPACE>/src/main/scala/CORDIC/CHISELtrig.scala
empty definition using pc, found symbol in pc: 
found definition using semanticdb; symbol chisel3/package.fromIntToWidth#W().
empty definition using fallback
non-local guesses:

offset: 4358
uri: file://<WORKSPACE>/src/main/scala/CORDIC/CHISELtrig.scala
text:
```scala
package CORDIC

import chisel3._
import chisel3.util._ // For Enum, log2Ceil, VecInit

// Companion object to hold pre-computed values and fixed-point helpers.
// These are used during Chisel generation, not synthesized into hardware directly.
object CordicSimplifiedConstants {
  val CORDIC_K_DBL: Double = 0.6072529350088813 // Gain of CORDIC rotation/vectoring
  val MAX_ITERATIONS_FOR_LUT = 64 // Maximum number of entries we can precompute for atan LUT

  /**
   * Converts a Double to a BigInt representing a fixed-point number.
   * @param x The Double value to convert.
   * @param fractionalBits The number of fractional bits in the fixed-point representation.
   * @param width The total bit width of the SInt.
   * @return BigInt representation of the fixed-point number.
   */
  def doubleToFixed(x: Double, fractionalBits: Int, width: Int): BigInt = {
    val scaled = x * (1L << fractionalBits)
    val rounded = Math.round(scaled)
    // Basic saturation to fit within the SInt width
    val maxVal = (1L << (width - 1)) - 1
    val minVal = -(1L << (width - 1))
    if (rounded > maxVal) {
        // println(s"WARN: Fixed point overflow for $x (scaled $scaled, rounded $rounded > $maxVal). Clamping.")
        maxVal
    } else if (rounded < minVal) {
        // println(s"WARN: Fixed point underflow for $x (scaled $scaled, rounded $rounded < $minVal). Clamping.")
        minVal
    } else {
        rounded
    }
  }

  /**
   * Generates the arctan lookup table (ROM content).
   * @param fractionalBits Number of fractional bits for angle representation.
   * @param width Total bit width for angle values.
   * @param numEntries Number of atan(2^-i) entries to generate.
   * @return A sequence of SInt literals for VecInit.
   */
  def getAtanLUT(fractionalBits: Int, width: Int, numEntries: Int): Seq[SInt] = {
    require(numEntries <= MAX_ITERATIONS_FOR_LUT,
      s"Requested LUT size $numEntries exceeds max precomputation limit of $MAX_ITERATIONS_FOR_LUT")
    (0 until numEntries).map { i =>
      val angle_rad = math.atan(math.pow(2.0, -i))
      doubleToFixed(angle_rad, fractionalBits, width).S(width.W)
    }
  }
}

class CordicSimplified(val width: Int, val cycleCount: Int, val integerBits: Int = 3) extends Module {
  // Parameter Validations
  require(width > 0, "Width must be positive")
  require(cycleCount > 0, "Cycle count must be positive")
  require(cycleCount <= CordicSimplifiedConstants.MAX_ITERATIONS_FOR_LUT,
    s"cycleCount $cycleCount exceeds ROM size available (${CordicSimplifiedConstants.MAX_ITERATIONS_FOR_LUT})")
  require(integerBits >= 1, "Integer bits must be at least 1 (for sign or small numbers)") // Allowing for values like 0.x or 1.x
  val fractionalBits: Int = width - 1 - integerBits // 1 bit for sign
  require(fractionalBits > 0, s"Fractional bits must be positive. Check width ($width) vs integerBits ($integerBits). FractionalBits = $fractionalBits")

  val io = IO(new Bundle {
    // Control
    val start = Input(Bool())
    val opModeIsArctan = Input(Bool()) // true for ArcTan (vectoring), false for Sin/Cos (rotation)

    // Data Inputs
    val targetTheta = Input(SInt(width.W)) // For Sin/Cos mode: target angle in radians (fixed-point)
    val inputX = Input(SInt(width.W))      // For ArcTan mode: X coordinate (fixed-point)
    val inputY = Input(SInt(width.W))      // For ArcTan mode: Y coordinate (fixed-point)

    // Data Outputs
    val done = Output(Bool())
    val cosOut = Output(SInt(width.W))    // Result for Sin/Cos (X' * K or just X'), or 0 for Arctan
    val sinOut = Output(SInt(width.W))    // Result for Sin/Cos (Y' * K or just Y'), or 0 for Arctan
    val arctanOut = Output(SInt(width.W)) // Result for ArcTan (accumulated angle Z'), or residual angle for Sin/Cos
  })

  // --- Fixed-point constants for CORDIC calculations ---
  val K_fixed = CordicSimplifiedConstants.doubleToFixed(CordicSimplifiedConstants.CORDIC_K_DBL, fractionalBits, width).S(width.W)
  // Initial X for Sin/Cos mode is 1.0 (scaled).
  // The Scala model applied K later. If pre-scaling by 1/K, this would be CordicSimplifiedConstants.doubleToFixed(1.0 / CordicSimplifiedConstants.CORDIC_K_DBL,...)
  // val X_INIT_SINCOS_fixed = CordicSimplifiedConstants.doubleToFixed(1.0 , fractionalBits, width).S(width.W)
  val X_INIT_SINCOS_fixed = 
  val Y_INIT_SINCOS_fixed = 0.S(width.@@W)

  // Arctan lookup table (ROM). Contents generated by getAtanLUT.
  val atanLUT = VecInit(CordicSimplifiedConstants.getAtanLUT(fractionalBits, width, cycleCount))

  // --- State Machine Definition ---
  val sIdle :: sProcessing :: sDone :: Nil = Enum(3)
  val state = RegInit(sIdle)

  // --- Registers for CORDIC iterative values ---
  val x_reg = Reg(SInt(width.W))
  val y_reg = Reg(SInt(width.W))
  val z_reg = Reg(SInt(width.W)) // Holds angle for rotation mode, accumulates angle for vectoring
  // iter_count goes from 0 to cycleCount-1 for iterations, then to cycleCount to signal completion
  val iter_count = Reg(UInt(log2Ceil(cycleCount + 1).W))
  val current_opModeIsArctan_reg = Reg(Bool()) // Store operation mode during processing

  // --- Default output values ---
  io.done := false.B
  io.cosOut := 0.S       // Default to 0 or hold previous value. Defaulting to 0.
  io.sinOut := 0.S
  io.arctanOut := 0.S

  // --- State Machine Logic ---
  switch(state) {
    is(sIdle) {
      when(io.start) {
        current_opModeIsArctan_reg := io.opModeIsArctan
        when(io.opModeIsArctan) { // ArcTan (Vectoring mode)
          // Scala model: assert(inputX >= 0). Assuming valid inputs.
          x_reg := io.inputX
          y_reg := io.inputY
          z_reg := 0.S(width.W) // Accumulator for angle
        }.otherwise { // Sin/Cos (Rotation mode)
          // Scala model: assert range for targetTheta. Assuming valid inputs.
          x_reg := X_INIT_SINCOS_fixed // Start with vector (1,0) effectively
          y_reg := Y_INIT_SINCOS_fixed
          z_reg := io.targetTheta      // Angle to reduce to zero
        }
        iter_count := 0.U
        state := sProcessing
      }
    }

    is(sProcessing) {
      // Perform iterations as long as iter_count < cycleCount
      when(iter_count < cycleCount.U) {
        val current_i = iter_count // Current iteration index, used for shifts and LUT access

        val y_shifted = y_reg >> current_i
        val x_shifted = x_reg >> current_i
        
        val delta_theta = atanLUT(current_i)
        val direction = Wire(SInt(2.W))      // Direction of rotation/vectoring (+1 or -1)

        when(current_opModeIsArctan_reg) { // Vectoring mode (calculating ArcTan)
          // Determine direction for vectoring mode
          // Scala: if (yPrime < 0) direction = 1 else direction = -1
          // To make y_reg approach 0:
          // If y_reg > 0, rotate negatively (standard CORDIC d_i = +1)
          // If y_reg < 0, rotate positively (standard CORDIC d_i = -1)
          val d_vec = Mux(y_reg >= 0.S, 1.S, -1.S)
          direction := d_vec // Assign to the common 'direction' wire

          x_reg := x_reg + (direction * y_shifted) // x_new = x_old + d*y_shifted
          y_reg := y_reg - (direction * x_shifted) // y_new = y_old - d*x_shifted
          z_reg := z_reg + (direction * delta_theta) // z_new = z_old + d*angle

        }.otherwise { // Rotation mode (calculating Sin/Cos)
          // Determine direction for rotation mode
          // Standard CORDIC: d_i = sign(z_i). If z_i > 0, d_i = +1 (rotate negative).
          val d_rot = Mux(z_reg >= 0.S, 1.S, -1.S)
          direction := d_rot // Assign to the common 'direction' wire
          
          x_reg := x_reg - (direction * y_shifted) // x_new = x_old - d*y_shifted
          y_reg := y_reg + (direction * x_shifted) // y_new = y_old + d*x_shifted
          z_reg := z_reg - (direction * delta_theta) // z_new = z_old - d*angle
        }
        iter_count := iter_count + 1.U
      }.otherwise { // All iterations (0 to cycleCount-1) are complete
        state := sDone
      }
    }

    is(sDone) {
      io.done := true.B
      // Values in x_reg, y_reg, z_reg are the final results from iterations.
      when(current_opModeIsArctan_reg) {
        // Scala model returned (0.0, 0.0, totalTheta)
        io.cosOut    := 0.S // x_reg would be gain-scaled magnitude if needed
        io.sinOut    := 0.S // y_reg should be close to 0 if needed
        io.arctanOut := z_reg // This is the accumulated angle
      }.otherwise { // Sin/Cos mode
        // x_reg is cos(theta_initial) * Product(cos(atan(2^-i))) = cos(theta_initial) / K_cordic
        // y_reg is sin(theta_initial) * Product(cos(atan(2^-i))) = sin(theta_initial) / K_cordic
        // Need to apply gain correction K_cordic.
        val cos_uncorrected = x_reg
        val sin_uncorrected = y_reg

        // Fixed point multiplication: (A * B) requires a right shift by fractionalBits
        // to realign the decimal point. The intermediate product can be up to 2*width bits.
        val cos_full_prod = cos_uncorrected.asSInt * K_fixed.asSInt
        val sin_full_prod = sin_uncorrected.asSInt * K_fixed.asSInt
        
        // Shift right to restore fractional point and truncate to original width.
        io.cosOut := (cos_full_prod >> fractionalBits.U).asSInt
        io.sinOut := (sin_full_prod >> fractionalBits.U).asSInt
        io.arctanOut := z_reg // This is the residual angle, should be close to zero
      }
      // After outputting for one cycle, return to Idle.
      // If io.start is held high, it might immediately start a new calculation.
      state := sIdle
    }
  }
}


```


#### Short summary: 

empty definition using pc, found symbol in pc: 